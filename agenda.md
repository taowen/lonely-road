# 第一篇：论述依赖管理决定了复用和可扩展性，由易变性驱动模块分解

* 底层模块尝试让自己实现更多的业务。举一个反面例子：计费系统。
* 顶层模块尝试让自己实现更多的业务。举一个反面例子：业务逻辑编排API。
* 顶层模块只服务于自己单一的业务。举一个正面的例子：vscode插件。或者其他类似的。
* 保险公司前后台业务的例子

从例子里总结出三种依赖关系的形状

* 自己代码量很大：这个不是问题。不是小前台，大中台的问题。
* 自己经常要被修改：这个才是关注的焦点。

总结的结论是

* 底层模块要本分，自己被很多人依赖了，就要保持稳定。少改动。
* 要有多个顶层模块，来服务于不同的业务变化方向。而不是用一个“编排层”来收口。

引出下一篇：没有最顶上一层的编排，那么多个顶层模块之间是什么关系?怎么集成呢? 

# 第二篇：模块之间的划分边界的常见模式，以及其优缺点

UI 集成：

* 使用UI集成的例子，使用opaque pointer的例子：amazon
* customer / product 两个表的例子
* hotel booking 的例子
* 商品编辑页，需要同时保存

把模块伪装在存储后面，时序上解耦合。允许延后计算（message queue），允许提前计算（pull），cache，on demand compute

* 提供一个command队列存储接口的：给一个通过message queue异步解耦的例子
* 用pull代替push的例子
* 浏览器的DOM是不是一个好例子?

command/control的关系，时序上紧耦合，反面例子

* DIP 不是灵丹妙药：举个例子
* bridge pattern
* trait
* role model synthesize

结论就是要更多的

* UI 集成
* opaque pointer
* 伪装成存储接口

那么为什么这些想法没有被绝大多数项目采纳，阻力在哪里?

* 可复用的系统不一定是最佳解决方案，给每个单独的用途开发单独的应用可能是更佳的方案
* UI往往是独立的团队，知识边界的限制
* 运行时都是在一起的，报错信息是在一起的，这么写很难和运行时的现象对应起来
* 需求可能是跨模块的，产品经理的分工调整，产品需求的粒度是经常变化的，导致一个产品经理需要改多个模块
* 编辑的时候往往需要在更多的模块/目录/文件之间跳转
* ...更多的理由

这些阻力是否可以被化解?

# 第三篇：通过引入新的模块化技术，实现可复用的系统

* 用普通的函数，调用子函数来示例模块化的需求
* 添加参数来表达多样性
* 全局变量传参 === 配置
* 用多态来代替 if/else：运行时组装代码

对应的

* 源代码 patch 机制
* role command 机制

其他模块化技术

* 端到端的整体打包
* 微前端
* vscode 插件，减少编辑成本
* 运行时 tracing


what changed

* bottom up v.s. top down (david parnas, ooram methods)
* ui hold back: microfrontend 
* persistence hold back
* static composition

# TODO

* 把第一个例子往中台和业务身份上引伸
* 把 MDA 的例子插入到第二个位置上
* 第三章以 problem - solution 的方式组织，把所有“行不通”理由罗列出来，逐个给解决方案